
#' @author  Michael Bleau
#' 2015-03-02
#'
#' Functions used across the EPRA Sampling package
#' 
#' Modified 2017-11-23
#'  - to add flexibility to Selection functions feeding drop-down lists (GeoSelection)
#'  
#' Modified 2017-12-08
#'  - removed all UI specific functions to a separate file: ShinyHelperFunctions.R 
#'
#' 2018-08-13 (MRB)
#'  - added date time stamping features inclding mods to BuildStats
#'  - BuildStats can optionally report progress to Shiny UI
#'
#'2019-05-23 (MRB)
#' - added GetTempFile function
#' 
#' @section Setup

require("data.table", quietly = TRUE)
options(digits=2)
options(scipen = 999) # to suppress scientific notation

#' @section Debug functions
#' 
dbgFile <- function() {
  console = TRUE
  if (console) {
    return("log/debug.log")
  }
  else {
    return(NULL)
  }
}

dbgLogInit <- function(msg = ""){
  cat("Initializing log at:", getwd(), dbgFile(), "\n")
  cat(date(), "Run: ", msg, "\n", file=dbgFile(), append = FALSE)
}

dbgLog <- function(title = "", msg = "", newline = TRUE){
  if (newline) {
    nl <- "\n"
  } else {
    nl <- ""
  }
  sink(dbgFile(), append = TRUE)
  cat(date(), title, msg, nl)
  sink()
}


#' @section Path and File names
#' Location of source data files

#' @name getOS
#' 
#' @description returns name of operating system
#' 
getOS <- function(){
  sysinf <- Sys.info()
  if (!is.null(sysinf)){
    os <- sysinf['sysname']
    if (os == 'Darwin')
      os <- "osx"
  } else { ## mystery machine
    os <- .Platform$OS.type
    if (grepl("^darwin", R.version$os))
      os <- "osx"
    if (grepl("linux-gnu", R.version$os))
      os <- "linux"
  }
  tolower(os)
}

# directory containing imported data stored in the R native format
RDataDirectory <- function() {
  rdd <- "data/"
}

# directory containing either text files for import into ESA (linux version) or
# sql files for import into R (Windows / ODBC)
ImportDirectory <- function(dirOffset = "") {
  id <- "import/"
}

# directory containing data exported from ESA
ExportDirectory <- function(dirOffset = "") {
  ed <- "export/"
}

# directory containing reports (  excel, pdf, etc.) generated by ESA
ReportDirectory <- function(dirOffset = "") {
  "reports/"
}

ToRFile <- function(filename) {
  paste(c(ImportDirectory(), filename), collapse = "")
}

CustomHierachyFile <- function(){
  f <- paste(c(ImportDirectory(), "CustomHierarchy.csv"), collapse = "")
  return(f)
} 

EPRASamplingErrorFile <- function(){
  f <- paste(c(RDataDirectory(), "EPRASamplingErrors"), collapse = "")
  return(f)
} 

EPRASamplingDataFile <- function(){
  f <- paste(c(RDataDirectory(), "EPRASamplingData"), collapse = "")
  return(f)
} 

EPRASamplingObsFile <- function(){
  f <- paste(c(RDataDirectory(), "EPRASamplingObs"), collapse = "")
  return(f)
} 

EPRASamplingStatsFile <- function(){
  f <- paste(c(RDataDirectory(), "EPRASamplingStats"), collapse = "")
  return(f)
} 

EPRADateTimeStampFile <- function(){
  f <- paste(c(RDataDirectory(), "EPRADateTimeStamp"), collapse = "")
  return(f)
} 

#' @name GetTempFile
#' 
#' @description 
#' returns a full path and file name that is safe to use
#' 
#' @param 
#' basename   the desired basename
#' ext        the desired extension.  The user must provide a leading "." if needed
#'            e.g.: ".pdf"
#' 
#' @details
#' the file name will be a fully configured name in the temp directory
#' files in this directory could be deleted at any time
#' the user is responsible for providing a basename and extension that are "legal' for whichever OS 
#' is being used
#' The returned file name is for immediate use
#' The path name will be compatible with the OS on which the server resides (e.g. backslashes in Windows)
#' Files in the temp directory can be deleted at any time
#' 
GetTempFile <- function(basename = "temp", ext = "")  {
  tempdir = normalizePath("tmp") # convert relative to full path
  fullname <- tempfile(basename, tempdir, ext)
  return(fullname)
}

#' retrieve a single data object data object 
#' from one of the error, data, obs or stats files
GetDataObject <- function(data){
  switch(data,
         "nodeObs" = {
           load(EPRASamplingObsFile())
           ob <- nodeObs
           return(ob)
         },
         "containerNodeBrandObs" = {
           load(EPRASamplingObsFile())
           ob <- containerNodeBrandObs
           return(ob)
         },
         "containerObs" = {
           load(EPRASamplingObsFile())
           ob <- containerObs
           return(ob)
         },
         "nodeStratumStats" = {
           load(EPRASamplingStatsFile())
           ob <- nodeStratumStats
           return(ob)
         },
         "nodeBrandStratumStats" = {
           load(EPRASamplingStatsFile())
           ob <- nodeBrandStratumStats
           return(ob)
         },
         "nodeLocationStratumStats" = {
           load(EPRASamplingStatsFile())
           ob <- nodeLocationStratumStats
           return(ob)
         },
         "importErrors" = {
           load(EPRASamplingErrorFile())
           return(importErrors)
         },
         {
           load(EPRASamplingDataFile())
           ob <- epradata[[data]]
           return(ob)
         }
  )
}

#' @section RebuildData
#' 
BuildStats <- function(epraData = TRUE, obs = TRUE, stats = TRUE, progress = NULL){
  BuildEPRAData <- function(){
    source("R/PrepareData.R")
    PrepareData()
  }
  
  BuildObs <- function(){
    source("R/PrepareStratumObs.R")
    PrepareStratumObs()
  }
  
  BuildStats <- function(){
    source("R/PrepareStratumStats.R")
    PrepareStats()
  }
  
  Progress <- function(detail, value) {
    if (is.function(progress)) {
      progress(detail = detail, value = value)
    }
  }
  
  dateTimeStamp = list(epraData = NULL, obs = NULL, stats = NULL)
  if (epraData) {
    cat("Loading data ... ")
    Progress("Data", 0/3)
    dateTimeStamp[["epraData"]] <- BuildEPRAData()
    cat("done\n")
  }
  
  if (obs) {
    cat("Generating observations ... ")
    Progress("Obs", 1/3)
    dateTimeStamp$obs <- BuildObs()
    cat("done\n")
  }
  
  if (stats) {
    cat("Calculating statistics ... ")
    Progress("Stats", 2/3)
    dateTimeStamp$stats <- BuildStats()
    cat("done\n")
  }
  
  Progress("Complete", 3/3)
  
  save(dateTimeStamp, file = EPRADateTimeStampFile())
}

GetDataLoadTiming <- function() {
  load(EPRADateTimeStampFile())
  if (is.null(dateTimeStamp$obs) | is.null(dateTimeStamp$stats)) {
    dateTimeStamp$consistencyFlag <- FALSE
  } else {
    dateTimeStamp$consistencyFlag <- dateTimeStamp$stats$start >= dateTimeStamp$obs$end & dateTimeStamp$obs$start >= dateTimeStamp$epraData$end
  }
  if (dateTimeStamp$consistencyFlag) {
    dateTimeStamp$officialTimeStamp <- dateTimeStamp$epraData$start
    dateTimeStamp$seconds <- difftime(dateTimeStamp$stats$end, dateTimeStamp$epraData$start, units = "secs")
  }
  return(dateTimeStamp)
}

#' statistical functions
#' 
#' 
normError <- function(sdev, obs, prec){
  precOneSide  <- 1 - (1 - prec)/2
  error  <- qnorm(precOneSide) * sdev / sqrt(obs)
}

upperCI <- function(mean, sdev, obs, prec = .95){
  error  <- normError(sdev, obs, prec)
  uci <- mean + error
}

lowerCI <- function(mean, sdev, obs, prec = .95, zerofloor = TRUE){
  error  <- normError(sdev, obs, prec)
  lci <- mean - error
  if (zerofloor){
    mean <- max(0, mean)
  }
  return(lci)
}

#' returns the minimum number of observations needed to 
#' establish whether a statistic can be considered normally distributed
minObs <- function(){
  return(30)
}

#' @section Miscellaneous Functions

#' data table cartesion join
Cartesian.dt = function(X,Y) {
  stopifnot(is.data.table(X),is.data.table(Y))
  k = NULL
  X = X[, c(k=1, .SD)]
  setkey(X, k)
  Y = Y[, c(k=1, .SD)]
  setkey(Y, NULL)
  X[Y, allow.cartesian=TRUE][, k := NULL]
}

#' @name Hash
#' 
#' @desc Convert a list of default 6 character identifiers to a unique character string
#' 
#' @param 
#' idList - List of integer or character values
#' width - max width of each hash element (default 6)
#' hashSep - separator between elements (default |)
#' 
#' @return character string
#' 
#' @details 
#' the hash was designed to be used in multistratum calculations to uniquely identify 
#' a list of subprograms and quarters whose statistics get combined
#'
Hash <- function(idlist, hashWidth = 6, hashSep = "|"){
  hashWidth = 6
  hashSep = "|"
  hash = ""
  for (id in idlist) {
    hash <- paste(hash, id, sep = hashSep)
  }
  return(hash)
}
#' @name UnHash
#' 
#' @desc retrieve a list of elements used to form a hash
#' 
#' @param
#' hash - the hash string
#' item - if 0 (the default) or less the full list is retrieved, otherwise the one-based element is retrieved
#' hashSep - separator between elements (default |)
#' 
#' @return character string ot list of character strings
#' 
#' @details 
#' if item is greater than the number of items in the string NULL is returned
#'
UnHash <- function(hash, item = 0, hashSep = "|"){
  l <- unlist(strsplit(hash, split = hashSep, fixed = TRUE))
  
  if(item > length(l)) {
    return(NULL)
  }
  
  if(item <= 0){
    return(l)
  }
  
  return(l[item])
}
