#' @name ProcessorComparisonReport.R
#' @author Michael Bleau
#' 
#' 
#' @description produces a shiny report comparing samplers
#' 2017-06-20
#' 

source("R/ShinyHelperFunctions.R")
source("R/UtilityFunctions.R")
source("R/PrepareMultistratStats.R")

# test Processor Comparison Report
pcTest <- function() {
  nodeSelection <- "1000"
  geoSelection  <-  "C0"
  timeSelection <-  "Y2016"
  activeOnly <- TRUE
  GetProcessorComparisonReport(nodeSelection, geoSelection, timeSelection, activeOnly = activeOnly)
}

#' @name GetProcessorComparisonReport
#' 
#' @return A datatable (meant for display in Shiny) comparing the sampling statistics of each sampling location (aka processor)
#' 
#' @param 
#' nodeID:             a single nodeID in the product hierarchy
#' geoSelection:       a string encoded to select a group of subprograms (see the GeoSelection function in ShinyHelperFunctions.R for coding info)
#' timeSelection:      a string encoded to select a group of quarters (see the TimeSelection function in  ShinyHelperFunctions for coding info).
#' activeOnly:         if TRUE only processors who have sampled more than 0 units are included
#' 
#' @description 
#' The data table contains the following columns: Processor, Units, Kg, Wt%, Kg/Unit, Damage%, Cannib%, Avg age (y), Avg screen size (cm)
#' It is sorted by processor name
#' The report presents the statistics generated by each processor for the nodeID, geoSelection and timeSelection specified in the input parameters.
#' All statistics calculations are unweighted
GetProcessorComparisonReport <- function(nodeID, 
                                         geoSelection,
                                         timeSelection,
                                         weighting = "unweighted",
                                         activeOnly = FALSE) {
  # retrieve stats
  strata <- as.data.table(StratumSelection(geoSelection, timeSelection))
  if (length(strata$strataID) == 0 ) {
    return(NULL)
  }
  msl <- strata[ , .(MultiStratumHash = "", StratumID = strataID)]
  statsList <- c(1, 2, 6, 7, 3, 8) # ordered list of needed stats
  
  stats <- MultiStratumTable(nodeSelectionTable = nodeID,
                             stratumSelectionTable = msl, 
                             statisticList = statsList, 
                             weighting = weighting,
                             locationID = TRUE)
  
  # keep only needed columns and rows (means)
  neededCols <- c("SamplingLocationID", "StatisticID", "units", "gr", "mean")
  stats <- stats[ , ..neededCols]
  
  # Initial columns (use weight ratio statistic for units and wt totals)
  contents <- stats[StatisticID == 1, 
                    .(SamplingLocationID, units, gr)]
  
  # Statistic columns - convert the statisticID variable to columns and attach to contents
  meanCols <- reshape(stats[, .(SamplingLocationID, StatisticID, meanCol = mean)],
                      idvar = "SamplingLocationID", timevar = "StatisticID", direction = "wide")
  contents <- merge(contents, meanCols, by = "SamplingLocationID")
  
  # Attach location name sort and drop the ID
  locationTable <- GetDataObject("samplingLocation")[ , .(SamplingLocationID, Sampler = Name)]
  contents <- merge(contents, locationTable, all.y = TRUE, by = "SamplingLocationID")[order(Sampler)]
  
  # select and sort table columns
  colNames <- c("Sampler", "units", "gr", paste0("meanCol.", statsList))
  contents <- contents[ ,..colNames]
  
  # if asked for, eliminate inactive processors
  if (activeOnly) {
    contents <- contents[units > 0]
  }
  
  # get display column names
  displayParameters <- DTImportDisplayParameters()
  statisticID <- c(NA, 1, 1, statsList)
  varNames <- c("", "units", "gr", rep("mean", times = length(statsList)))
  displayColumnNames <- DTGetDisplayColumns(statisticID = statisticID,
                                            variables = varNames,
                                            displayParameters = displayParameters)
  displayColumnNames[1] <- "Sampler"
  
  caption <- DTGetReportCaption("Processor Comparison Report",
                                nodeSelection = nodeID,
                                geoSelection = geoSelection,
                                timeSelection = timeSelection,
                                weighting = weighting)
  
  # format the data into a datatable for use in Shiny
  dt <- datatable(contents,
                  colname =  displayColumnNames,
                  style = "default",
                  rownames = FALSE,
                  escape = TRUE,
                  caption = caption,
                  extensions = 'Buttons',  #added by Andrew  Dec 15 2016 to support download buttons
                  options = list(dom = 'Bt', #change from 't' to 'bt' by Andrew  Dec 15 2016 to support download buttons
                                 buttons = c('copy', 'csv', 'excel', 'pdf', 'print'), #added by Andrew  Dec 15 2016 to support download buttons
                                 pageLength = -1L,
                                 columnDefs = list(list(visible = FALSE, targets = ncol(contents) - 1)) # hide the level column
                  )
  ) 
  dt <- DTPostProcess(shinyTable = dt,
                      statisticID = statisticID,
                      columnVars = varNames,
                      displayParameters = displayParameters)
  return(dt)
}